{"version":3,"file":"promise.js","sourceRoot":"","sources":["../../../../src/polyfills/promise.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,cAAc,EAAE,aAAa,EAAoB,MAAM,qBAAqB,CAAC;AACtF,OAAO,EAAE,qBAAqB,EAAE,4BAA4B,EAAE,qBAAqB,EAAE,kBAAkB,EAAE,sBAAsB,EAAE,0BAA0B,EAAE,0BAA0B,EAAE,MAAM,yBAAyB,CAAC;AAKzN,IAAM,iBAAiB,GAAW,cAAc,uCAA2D,CAAC;AAsL5G;;;;;;;GAOG;AACH,MAAM,CAAC,IAAI,WAAW,GAAG,aAAa,CAAA,CAAC;IACnC;;;;;;OAMG;IACH,SAAS,eAAe,CAAI,QAA4B;QACpD,IAAI,CAAC,EAAE,GAAG,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,iBAAiB,EAAE;YACnB,IAAI,CAAC,iBAAiB,CAAC,GAAG,SAAS,CAAC;SACvC;QACD,gDAAgD;QAChD,aAAa,CAAC,IAAI,EAAE,OAAO,EAAE;YACzB,GAAG,EAAE;gBACD,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC;YACzB,CAAC;SACJ,CAAC,CAAC;IACP,CAAC;IAED;OACG;IACH,eAAe,CAAC,GAAG,GAAG,qBAAqB,CAAC;IAC5C,eAAe,CAAC,IAAI,GAAG,sBAAsB,CAAC;IAC9C,eAAe,CAAC,GAAG,GAAG,qBAAqB,CAAC;IAC5C,eAAe,CAAC,MAAM,GAAG,0BAA0B,CAAC;IACpD,eAAe,CAAC,OAAO,GAAG,0BAA0B,CAAC;IACrD,eAAe,CAAC,UAAU,GAAG,4BAA4B,CAAC;IAC1D,IAAI,QAAQ,GAAG,eAAe,CAAC,SAAS,CAAC;IACzC,QAAQ,CAAC,IAAI,GAAG,UAAU,UAAe,EAAE,UAAe;QACtD,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;IAChD,CAAC,CAAC;IACF,QAAQ,CAAC,KAAK,GAAG,UAAU,UAAe;QACtC,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IACrC,CAAC,CAAC;IACF,QAAQ,CAAC,OAAO,GAAG,UAAU,SAAc;QACvC,OAAO,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACtC,CAAC,CAAC;IACF,OAAO,eAAoD,CAAC;AAChE,CAAC,EAAE,CAAC,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getKnownSymbol, objDefineProp, WellKnownSymbols } from \"@nevware21/ts-utils\";\r\nimport { createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncAnyPromise, createAsyncPromise, createAsyncRacePromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"../promise/asyncPromise\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\nconst toStringTagSymbol: symbol = getKnownSymbol(WellKnownSymbols.toStringTag) as typeof Symbol.toStringTag;\r\n\r\n/**\r\n * The PolyPromiseConstructor interface represents the constructor for the polyfill Promise object.\r\n * @since 0.5.0\r\n * @group Polyfill\r\n */\r\nexport interface PolyPromiseConstructor {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    new <T>(executor: PromiseExecutor<T>): IPromise<T>;\r\n\r\n    /**\r\n     * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n     * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n     * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n     * and will reject with this first rejection message / error.\r\n     * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns\r\n     * <ul>\r\n     * <li> An already resolved `Promise`, if the input passed is empty.\r\n     * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n     * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n     * promises reject.\r\n     * </ul>\r\n     */\r\n    all<T>(input: Iterable<PromiseLike<T>>, timeout?: number): IPromise<T[]>;\r\n\r\n    /**\r\n     * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n     * settles with the eventual state of the first promise that settles.\r\n     * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n     * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n     * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n     * the first of these values found in the iterable.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n     * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n     * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n     * asynchronously settled.\r\n     */\r\n    race<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n    /**\r\n     * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n     * settles with the eventual state of the first promise that settles.\r\n     * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n     * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n     * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n     * the first of these values found in the iterable.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n     * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n     * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n     * asynchronously settled.\r\n     */\r\n    race<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>>;\r\n\r\n    /**\r\n     * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n     * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n     * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n     * AggregateError containing an array of rejection reasons.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A new Promise that is:\r\n     * - Already rejected, if the iterable passed is empty.\r\n     * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n     * is the fulfillment value of the first promise that was fulfilled.\r\n     * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n     * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n     * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n     * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n     * rejected.\r\n     */\r\n    any<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n    /**\r\n     * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n     * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n     * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n     * AggregateError containing an array of rejection reasons.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A new Promise that is:\r\n     * - Already rejected, if the iterable passed is empty.\r\n     * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n     * is the fulfillment value of the first promise that was fulfilled.\r\n     * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n     * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n     * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n     * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n     * rejected.\r\n     */\r\n    any<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>>;\r\n\r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n     * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n     * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param reason - The rejection reason\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns A rejected promise.\r\n     */\r\n    reject<T = never>(reason?: any, timeout?: number): IPromise<T>;\r\n \r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n     * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n     * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n     * @group Polyfill\r\n     * @returns A resolved promise.\r\n     */\r\n    resolve(): IPromise<void>;\r\n \r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n     * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n     * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns A resolved promise.\r\n     */\r\n    resolve<T>(value: T | PromiseLike<T>, timeout?: number): IPromise<T>;\r\n\r\n    /**\r\n     * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations based on the\r\n     * {@link createAsyncPromise Aasynchronous} promise implementation. Any chained operations will execute\r\n     * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n     * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n     * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n     * each promise.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n     */\r\n    allSettled<T extends readonly unknown[] | []>(values: T, timeout?: number): Promise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>;\r\n\r\n    /**\r\n     * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations based on the\r\n     * {@link createAsyncPromise Aasynchronous} promise implementation. Any chained operations will execute\r\n     * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n     * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n     * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n     * each promise.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n     */\r\n    allSettled<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n}\r\n\r\n/**\r\n * A full polyfill for the Promise class.\r\n * Represents the completion of an asynchronous operation, and its resulting value.\r\n * @since 0.5.0\r\n * @class\r\n * @group Polyfill\r\n * @group Promise\r\n */\r\nexport let PolyPromise = /*#__PURE__*/(function () {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    function PolyPromiseImpl<T>(executor: PromiseExecutor<T>) {\r\n        this._$ = createAsyncPromise(executor);\r\n        if (toStringTagSymbol) {\r\n            this[toStringTagSymbol] = \"Promise\";\r\n        }\r\n        // Re-Expose the state of the underlying promise\r\n        objDefineProp(this, \"state\", {\r\n            get: function() {\r\n                return this._$.state;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     */\r\n    PolyPromiseImpl.all = createAsyncAllPromise;\r\n    PolyPromiseImpl.race = createAsyncRacePromise;\r\n    PolyPromiseImpl.any = createAsyncAnyPromise;\r\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\r\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\r\n    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\r\n    let theProto = PolyPromiseImpl.prototype;\r\n    theProto.then = function (onResolved: any, onRejected: any) {\r\n        return this._$.then(onResolved, onRejected);\r\n    };\r\n    theProto.catch = function (onRejected: any) {\r\n        return this._$.catch(onRejected);\r\n    };\r\n    theProto.finally = function (onfinally: any) {\r\n        return this._$.finally(onfinally);\r\n    };\r\n    return PolyPromiseImpl as unknown as PolyPromiseConstructor;\r\n}());"]}