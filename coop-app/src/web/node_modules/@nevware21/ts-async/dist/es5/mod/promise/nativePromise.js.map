{"version":3,"file":"nativePromise.js","sourceRoot":"","sources":["../../../../src/promise/nativePromise.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AACpD,OAAO,EAAE,iBAAiB,EAAE,wBAAwB,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,sBAAsB,EAAE,sBAAsB,EAAE,MAAM,QAAQ,CAAC;AAE5J,OAAO,EAAiB,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAEjE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,aAAa,EAAE,cAAc,EAAE,OAAO,EAAgB,iBAAiB,EAAE,IAAI,EAAE,MAAM,qBAAqB,CAAC;AACzI,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AAGpD;;;;GAIG;AACH,IAAI,UAAU,GAAY,IAAI,CAAC;AAE/B;;;;GAIG;AACH,IAAI,WAA6C,CAAC;AAElD;;;;GAIG;AACH,IAAI,WAAqH,CAAC;AAE1H;;;;GAIG;AACH,IAAI,wBAAiL,CAAC;AAEtL;;;;GAIG;AACH,IAAI,kBAAkI,CAAC;AAEvI;;;;GAIG;AACH,IAAI,iBAAiI,CAAC;AAEtI;;;;;GAKG;AACH,MAAM,UAAU,kBAAkB,CAAC,SAAkB;IACrD,eAAe;IACf,2CAA2C;IAC3C,4CAA4C;IAC5C,4CAA4C;IAC5C,yDAAyD;IACzD,mDAAmD;IACnD,kDAAkD;IAClD,QAAQ;AACR,CAAC;AAED,wBAAwB;AACxB,MAAM,UAAU,0BAA0B,CAAI,IAAY,EAAE,IAA2B;IACnF,CAAC,WAAW,IAAI,CAAC,WAAW,GAAG,iBAAiB,CAAqB,CAAC,UAAU,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,IAAW,CAAC,CAAC,CAAC;IACrI,IAAI,WAAW,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;QACtC,OAAO,iBAAiB,CAAC,UAA4C,KAAQ,EAAE,OAAgB;YAC3F,OAAO,mBAAmB,CAAC,UAAC,OAAO,EAAE,MAAM;gBACvC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YACrD,CAAC,CAAC,CAAC;QACP,CAAM,CAAC,CAAC;KACX;IAED,OAAO,IAAI,EAAE,CAAC;AAClB,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,mBAAmB,CAAI,QAA4B,EAAE,OAAgB;IACjF,CAAC,WAAW,IAAI,CAAC,WAAW,GAAG,iBAAiB,CAAqB,CAAC,UAAU,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,IAAW,CAAC,CAAC,CAAC;IACrI,IAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC;IAC7B,IAAI,CAAC,MAAM,EAAE;QACT,OAAO,kBAAkB,CAAC,QAAQ,CAAC,CAAC;KACvC;IAED,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QACvB,cAAc,CAAC,WAAW,GAAG,iCAAiC,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;KACvF;IAED,IAAI,MAAM,gCAAwB,CAAC;IAEnC,SAAS,SAAS;QACd,OAAO,aAAa,CAAC,MAAM,CAAC,CAAC;IACjC,CAAC;IAED,IAAI,UAAU,GAAG,IAAI,MAAM,CAAI,UAAC,OAAO,EAAE,MAAM;QAC3C,SAAS,QAAQ,CAAC,KAAQ;YACtB,MAAM,iCAAyB,CAAC;YAChC,OAAO,CAAC,KAAK,CAAC,CAAC;QACnB,CAAC;QAED,SAAS,OAAO,CAAC,MAAW;YACxB,MAAM,iCAAyB,CAAC;YAChC,MAAM,CAAC,MAAM,CAAC,CAAC;QACnB,CAAC;QAED,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAEhC,CAAC,CAAgB,CAAC;IAElB,aAAa,CAAC,UAAU,EAAE,OAAO,EAAE;QAC/B,GAAG,EAAE,SAAS;KACjB,CAAC,CAAC;IAEH,OAAO,UAAU,CAAC;AACtB,CAAC;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,MAAM,UAAU,sBAAsB,CAAI,KAA+B,EAAE,OAAgB;IACvF,CAAC,WAAW,IAAI,CAAC,WAAW,GAAG,0BAA0B,CAAC,KAAK,EAAE,cAAM,OAAA,iBAAiB,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC,EAAzD,CAAyD,CAAC,CAAC,CAAC;IACnI,OAAO,WAAW,CAAC,CAAC,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AACzC,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,IAAM,2BAA2B,GAAmD,aAAa,CAAA,sBAAsB,CAAC,mBAAmB,CAAC,CAAC;AAEpJ;;;;;;;;;;GAUG;AACH,MAAM,CAAC,IAAM,2BAA2B,GAA+D,aAAa,CAAA,sBAAsB,CAAC,mBAAmB,CAAC,CAAC;AAwChK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCG;AACH,MAAM,UAAU,6BAA6B,CAAoC,KAAQ,EAAE,OAAgB;IACvG,CAAC,wBAAwB,IAAI,CAAC,wBAAwB,GAAG,0BAA0B,CAAC,YAAY,EAAE,cAAM,OAAA,wBAAwB,CAAC,mBAAmB,CAAC,EAA7C,CAA6C,CAAC,CAAC,CAAC;IACxJ,OAAO,wBAAwB,CAAC,CAAC,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AACtD,CAAC;AAuBD;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,UAAW,uBAAuB,CAAoC,MAAS,EAAE,OAAgB;IACnG,CAAC,kBAAkB,IAAI,CAAC,kBAAkB,GAAG,0BAA0B,CAAC,MAAM,EAAE,cAAM,OAAA,kBAAkB,CAAC,mBAAmB,CAAC,EAAvC,CAAuC,CAAC,CAAC,CAAC;IAChI,OAAO,kBAAkB,CAAC,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACjD,CAAC;AA0BD;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,UAAU,sBAAsB,CAAoC,MAAS,EAAE,OAAgB;IACjG,CAAC,iBAAiB,IAAI,CAAC,iBAAiB,GAAG,0BAA0B,CAAC,KAAK,EAAE,cAAM,OAAA,iBAAiB,CAAC,mBAAmB,CAAC,EAAtC,CAAsC,CAAC,CAAC,CAAC;IAC5H,OAAO,iBAAiB,CAAC,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAChD,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { createAsyncPromise } from \"./asyncPromise\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { dumpObj, isFunction, objDefineProp, throwTypeError, getInst, ICachedValue, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Flag to determine if the native Promise class should be used if available, used for testing purposes.\r\n */\r\nlet _useNative: boolean = true;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the native Promise class\r\n */\r\nlet _promiseCls: ICachedValue<PromiseConstructor>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.all` method\r\n */\r\nlet _allCreator: ICachedValue<<T>(input: Iterable<T | PromiseLike<T>>, ...additionalArgs: any) => IPromise<Awaited<T>[]>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.allSettled` method\r\n */\r\nlet _allNativeSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.race` method\r\n */\r\nlet _raceNativeCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.any` method\r\n */\r\nlet _anyNativeCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Test Hook function to clear the cached values and set whether to use the native Promise class\r\n * @param useNative\r\n */\r\nexport function _clearPromiseCache(useNative: boolean) {\r\n//#ifdef _DEBUG\r\n//#:(!_DEBUG)     _useNative = !!useNative;\r\n//#:(!_DEBUG)     _promiseCls = null as any;\r\n//#:(!_DEBUG)     _allCreator = null as any;\r\n//#:(!_DEBUG)     _allNativeSettledCreator = null as any;\r\n//#:(!_DEBUG)     _raceNativeCreator = null as any;\r\n//#:(!_DEBUG)     _anyNativeCreator = null as any;\r\n//#endif\r\n}\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createNativePromiseHelper<F>(name: string, func: () => ICachedValue<F>): ICachedValue<F> {\r\n    !_promiseCls && (_promiseCls = createCachedValue<PromiseConstructor>((_useNative && safe(getInst, [STR_PROMISE]).v) || null as any));\r\n    if (_promiseCls.v && _promiseCls.v[name]) {\r\n        return createCachedValue(function<T extends readonly unknown[] | []>(input: T, timeout?: number) {\r\n            return createNativePromise((resolve, reject) => {\r\n                _promiseCls.v[name](input).then(resolve, reject);\r\n            });\r\n        } as F);\r\n    }\r\n    \r\n    return func();\r\n}\r\n\r\n/**\r\n * Creates a Promise instance that when resolved or rejected will execute it's pending chained operations using the\r\n * available native Promise implementation.\r\n * If runtime does not support native `Promise` class (or no polyfill is available) this function will fallback to using\r\n * `createAsyncPromise` which will resolve them __asynchronously__ using the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * @group Alias\r\n * @group Promise\r\n * @group Native\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createNativePromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T> {\r\n    !_promiseCls && (_promiseCls = createCachedValue<PromiseConstructor>((_useNative && safe(getInst, [STR_PROMISE]).v) || null as any));\r\n    const PrmCls = _promiseCls.v;\r\n    if (!PrmCls) {\r\n        return createAsyncPromise(executor);\r\n    }\r\n\r\n    if (!isFunction(executor)) {\r\n        throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpObj(executor));\r\n    }\r\n\r\n    let _state = ePromiseState.Pending;\r\n\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    let thePromise = new PrmCls<T>((resolve, reject) => {\r\n        function _resolve(value: T) {\r\n            _state = ePromiseState.Resolved;\r\n            resolve(value);\r\n        }\r\n\r\n        function _reject(reason: any) {\r\n            _state = ePromiseState.Rejected;\r\n            reject(reason);\r\n        }\r\n\r\n        executor(_resolve, _reject);\r\n\r\n    }) as IPromise<T>;\r\n\r\n    objDefineProp(thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    return thePromise;\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @group Native\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport function createNativeAllPromise<T>(input: Iterable<PromiseLike<T>>, timeout?: number): IPromise<T[]> {\r\n    !_allCreator && (_allCreator = _createNativePromiseHelper(\"all\", () => createCachedValue(_createAllPromise(createNativePromise))));\r\n    return _allCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @group Native\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createNativeResolvedPromise: <T>(value: T, timeout?: number) => Promise<T> =  /*#__PURE__*/_createResolvedPromise(createNativePromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @group Native\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createNativeRejectedPromise: <T = unknown>(reason: any, timeout?: number) => Promise<T> = /*#__PURE__*/_createRejectedPromise(createNativePromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper(\"allSettled\", () => _createAllSettledPromise(createNativePromise)));\r\n    return _allNativeSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function createNativeRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function  createNativeRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper(\"race\", () => _createRacePromise(createNativePromise)));\r\n    return _raceNativeCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createNativeAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createNativeAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper(\"any\", () => _createAnyPromise(createNativePromise)));\r\n    return _anyNativeCreator.v(values, timeout);\r\n}\r\n"]}