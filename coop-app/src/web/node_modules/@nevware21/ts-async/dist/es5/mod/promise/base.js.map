{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../../src/promise/base.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined,\r\n    throwTypeError, WellKnownSymbols, objToString, scheduleTimeout, ITimerHandler, getWindow, isNode,\r\n    getGlobal, ILazyValue, objDefine, objDefineProp, lazySafeGetInst, iterForOf, isIterable,\r\n    isArray, arrForEach, createCachedValue, ICachedValue, safe, getInst, createCustomError\r\n} from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"./await\";\r\nimport { _addDebugState, _promiseDebugEnabled } from \"./debug\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromisePendingProcessor } from \"./itemProcessor\";\r\nimport {\r\n    FinallyPromiseHandler, PromiseCreatorFn, PromiseExecutor, RejectedPromiseHandler, ResolvedPromiseHandler\r\n} from \"../interfaces/types\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { REJECTED, STR_PROMISE } from \"../internal/constants\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"./debug\";\r\n//#endif\r\n\r\nconst NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nconst UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\n\r\nlet _currentPromiseId: number[] = [];\r\nlet _uniquePromiseId = 0;\r\nlet _unhandledRejectionTimeout = 10;\r\nlet _aggregationError: ICachedValue<any>;\r\n\r\nlet _hasPromiseRejectionEvent: ILazyValue<any>;\r\n\r\nfunction dumpFnObj(value: any) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n\r\n    return dumpObj(value);\r\n}\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) function _getCaller(prefix: string, start: number) {\r\n//#:(!DEBUG)     let stack = new Error().stack;\r\n//#:(!DEBUG)     if (stack) {\r\n//#:(!DEBUG)         let lines = stack.split(\"\\n\");\r\n//#:(!DEBUG)         if (lines.length > start) {\r\n//#:(!DEBUG)             return prefix + \":\" + arrSlice(lines, start, start + 5).join(\"\\n\") + \"\\n...\";\r\n//#:(!DEBUG)         }\r\n//#:(!DEBUG)     }\r\n//#:(!DEBUG)     return null;\r\n//#:(!DEBUG) }\r\n//#endif\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createAggregationError(values: any[]) {\r\n    !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, [\"AggregationError\"]).v || createCustomError(\"AggregationError\", (self, args) => {\r\n        self.errors = args[0];\r\n    })));\r\n\r\n    return new _aggregationError.v(values);\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>, ...additionalArgs: any): IPromise<T>;\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>): IPromise<T> {\r\n    let additionalArgs = arrSlice(arguments, 3);\r\n    let _state = ePromiseState.Pending;\r\n    let _hasResolved = false;\r\n    let _settledValue: T;\r\n    let _queue: (() => void)[] = [];\r\n    let _id = _uniquePromiseId++;\r\n    let _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    let _handled = false;\r\n    let _unHandledRejectionHandler: ITimerHandler = null;\r\n    let _thePromise: IPromise<T>;\r\n\r\n    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + \"RejectionEvent\"));\r\n    \r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    function _then<TResult1 = T, TResult2 = never>(onResolved?: ResolvedPromiseHandler<T, TResult1>, onRejected?: RejectedPromiseHandler<TResult2>): IPromise<TResult1 | TResult2> {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n\r\n            let thenPromise = newPromise<TResult1, TResult2>(function (resolve, reject) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _getCaller(\"_then\", 7));\r\n                //#endif\r\n\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        let handler = _state === ePromiseState.Resolved ? onResolved : onRejected;\r\n                        let value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n    \r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve as any, reject);\r\n                        } else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value as any);\r\n                        } else if (_state === ePromiseState.Rejected) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        } else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value as any);\r\n                        }\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n    \r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n    \r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n    \r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n    \r\n            return thenPromise;\r\n    \r\n        } finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    function _catch<TResult1 = T>(onRejected: RejectedPromiseHandler<TResult1>) {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    function _finally<TResult1 = T, TResult2 = never>(onFinally: FinallyPromiseHandler): IPromise<TResult1 | TResult2> {\r\n        let thenFinally: any = onFinally;\r\n        let catchFinally: any = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function(value: TResult1 | TResult2) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            }\r\n    \r\n            catchFinally = function(reason: any) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            }\r\n        }\r\n\r\n        return _then<TResult1, TResult2>(thenFinally as any, catchFinally as any);\r\n    }\r\n\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    function _processQueue() {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            let pending = _queue.slice();\r\n            _queue = [];\r\n\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n\r\n        } else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    }\r\n\r\n    function _createSettleIfFn(newState: ePromiseState, allowState: ePromiseState) {\r\n        return (theValue: T) => {\r\n            if (_state === allowState) {\r\n                if (newState === ePromiseState.Resolved && isPromiseLike(theValue)) {\r\n                    _state = ePromiseState.Resolving;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(\r\n                        _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Resolving),\r\n                        _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Resolving));\r\n                    return;\r\n                }\r\n\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === ePromiseState.Rejected && !_unHandledRejectionHandler) {\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Setting up unhandled rejection\");\r\n                    //#endif\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout)\r\n                }\r\n            } else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    }\r\n\r\n    function _notifyUnhandledRejection() {\r\n        if (!_handled) {\r\n            // Mark as handled so we don't keep notifying\r\n            _handled = true;\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            } else {\r\n                let gbl = getWindow() || getGlobal();\r\n    \r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, (theEvt: any) => {\r\n                    objDefine(theEvt, \"promise\", { g: () => _thePromise });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    }\r\n\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    } as any;\r\n\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, () => { return objToString(_settledValue); }, () => _handled);\r\n    }\r\n\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol<symbol>(WellKnownSymbols.toStringTag)] = \"IPromise\";\r\n    }\r\n\r\n    let createStack: string;\r\n    //#if DEBUG\r\n    //#:(!{DEBUG}) createStack = _getCaller(\"Created\", 5);\r\n    //#endif\r\n    function _toString() {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\") + (createStack ? \" @ \" + createStack : \"\");\r\n    }\r\n\r\n    _thePromise.toString = _toString;\r\n\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n\r\n        const _rejectFn = _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Pending);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(\r\n                _thePromise,\r\n                _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Pending),\r\n                _rejectFn);\r\n        } catch (e) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Exception thrown: \" + dumpFnObj(e));\r\n            //#endif\r\n            _rejectFn(e);\r\n        }\r\n\r\n        //#ifdef DEBUG\r\n        //#:(!DEBUG) _debugLog(_toString(), \"~Executing\");\r\n        //#endif\r\n    })();\r\n\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllPromise(newPromise: PromiseCreatorFn): <T>(input: Iterable<T | PromiseLike<T>>, ...additionalArgs: any) => IPromise<Awaited<T>[]> {\r\n    return function <T>(input: Iterable<T | PromiseLike<T>>): IPromise<Awaited<T>[]> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T>[]>((resolve, reject) => {\r\n            try {\r\n                let values = [] as any;\r\n                let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n                iterForOf(input, (item, idx) => {\r\n                    if (item) {\r\n                        pending++;\r\n                        doAwait(item, (value) => {\r\n                            // Set the result values\r\n                            values[idx] = value;\r\n                            if (--pending === 0) {\r\n                                resolve(values);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createResolvedPromise(newPromise: PromiseCreatorFn): <T>(value: T, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(value: T): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike<T>(value)) {\r\n            return value as unknown as IPromise<T>;\r\n        }\r\n    \r\n        return newPromise((resolve) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Resolving Promise\");\r\n            //#endif\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRejectedPromise(newPromise: PromiseCreatorFn): <T>(reason: any, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(reason: any): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise((_resolve, reject) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Rejecting Promise\");\r\n            //#endif\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function which when called will return a new Promise object that resolves to an array of\r\n * IPromiseResults from the input promises. The returned promise will resolve when all of the inputs'\r\n * promises have resolved or rejected, or if the input contains no promises. It will resolve only after\r\n * all input promises have been fulfilled (resolve or rejected).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllSettledPromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>> {\r\n    return createCachedValue(function <T>(input: T, ..._args: any[]): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>((resolve, reject) => {\r\n            let values: { -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; } = [] as any;\r\n            let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n            function processItem(item: any, idx: number) {\r\n                pending++;\r\n                doAwaitResponse(item, (value) => {\r\n                    if (value.rejected) {\r\n                        values[idx] = {\r\n                            status: REJECTED,\r\n                            reason: value.reason\r\n                        };\r\n                    } else {\r\n                        values[idx] = {\r\n                            status: \"fulfilled\",\r\n                            value: value.value\r\n                        };\r\n                    }\r\n                \r\n                    if (--pending === 0) {\r\n                        resolve(values);\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise settles with the eventual state of the first promise that settles.\r\n * @description The returned promise is one of the promise concurrency methods. It's useful when you want\r\n * the first async task to complete, but do not care about its eventual state (i.e. it can either succeed\r\n * or fail).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the first promise to settle is fulfilled,\r\n * and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises,\r\n * the returned promise is still settled.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function  _createRacePromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>> {\r\n    return createCachedValue(function <T extends readonly unknown[] | []>(input: T, ..._args: any[]): IPromise<Awaited<T[number]>> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T[number]>>((resolve, reject) => {\r\n            let isDone = false;\r\n\r\n            function processItem(item: any) {\r\n                doAwaitResponse(item, (value) => {\r\n                    if (!isDone) {\r\n                        isDone = true;\r\n                        if (value.rejected) {\r\n                            reject(value.reason);\r\n                        } else {\r\n                            resolve(value.value);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment\r\n * value. It rejects when all of the input's promises reject (including when an empty iterable is passed),\r\n * with an AggregateError containing an array of rejection reasons.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the any of the input's promises fulfills,\r\n * with this first fulfillment value. It rejects when all of the input's promises reject (including when\r\n * an empty iterable is passed), with an AggregateError containing an array of rejection reasons.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function  _createAnyPromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(values: T) => IPromise<Awaited<T[number]>>> {\r\n    return createCachedValue(function <T extends readonly unknown[] | []>(input: T, ..._args: any[]): IPromise<Awaited<T[number]>> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T[number]>>((resolve, reject) => {\r\n            let theErros: Array<any> = [] as any;\r\n            let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n            let isDone = false;\r\n\r\n            function processItem(item: any, idx: number) {\r\n                pending++;\r\n                doAwaitResponse(item, (value ) => {\r\n                    if (!value.rejected) {\r\n                        isDone = true;\r\n                        resolve(value.value);\r\n                        return;\r\n                    } else {\r\n                        theErros[idx] = value.reason;\r\n                    }\r\n\r\n                    if (--pending === 0 && !isDone) {\r\n                        reject(_createAggregationError(theErros));\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0 && !isDone) {\r\n                    // All promises were either resolved or where not a promise\r\n                    reject(_createAggregationError(theErros));\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n"]}