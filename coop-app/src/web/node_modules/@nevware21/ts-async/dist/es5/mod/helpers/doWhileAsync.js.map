{"version":3,"file":"doWhileAsync.js","sourceRoot":"","sources":["../../../../src/helpers/doWhileAsync.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isFunction, isPromiseLike, utcNow } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { createPromise } from \"../promise/promise\";\r\nimport { doAwait } from \"../promise/await\";\r\nimport { RejectPromiseHandler, ResolvePromiseHandler } from \"../interfaces/types\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\n\r\nfunction _doneChk<T>(isDone: boolean, state: IWhileState<T>, value: T, thisArg?: any) {\r\n    let result: boolean | IPromise<boolean> = isDone;\r\n    state.res = value;\r\n    if (!result) {\r\n        if (state.isDone && isFunction(state.isDone)) {\r\n            // Handle synchronous or asynchronous isDone function\r\n            return doAwait(state.isDone.call(thisArg, state), (done) => {\r\n                state.iter++;\r\n                return !!done;\r\n            });\r\n        } else {\r\n            result = !!state.isDone;\r\n        }\r\n    }\r\n\r\n    state.iter++;\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs a while loop, calling the provided `callbackFn` function until the `state.isDone`\r\n * property is set to `true` or the optional `isDOneFn` returns `true`. The callback function will\r\n * receive a single {@link IWhileState state} argument and may return either a value or a promise,\r\n * if a promise is returned the while loop will wait until the promise is resolved before calling\r\n * the callback function again. If the callback function never returns a promise the while loop\r\n * will be executed synchronous and last value returned by the callback will be returned, if the\r\n * callback function returns a promise the while loop will be asynchronous and an {@link IPromise}\r\n * will be returned and resolved with the last value returned by the callback or rejected if the\r\n * callback promise rejects or throws an error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @typeParam T - Identifies the element type returned by the callback function.\r\n * @param callbackFn A function that will be called until the `state.isDone` flag is set to `true`\r\n * the function will receive a single {@link IWhileState state} argument. The callback function\r\n * may return either a value or a promise, if a promise is returned the while loop will wait\r\n * until the promise is resolved before calling the callback function again.\r\n * @param isDoneFn An optional function that will be called after the callback function is called,\r\n * that can be used to stop the while loop. The function will receive a single {@link IWhileState state}\r\n * argument. If the function returns `true` the while loop will stop, otherwise the while loop will continue.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n * If thisArg is omitted, null or undefined the array will be used as the this value.\r\n * @remarks\r\n * - If an `isDoneFn` is provided the `state.isDone` property will be set to the provided value and\r\n * is accessible withing the callback function. The callbackFn may overwrite the value of the\r\n * `state.isDone` property within the callback function with a boolean value or another function that\r\n * returns a boolean value.\r\n * - The callback function is called until until the `state.isDone` property is set to `true` or if\r\n * `state.isDone` is a function until the function returns `true.\r\n * - The callback function will receive a single {@link IWhileState state} argument that contains\r\n * the following properties:\r\n *  - `iter` - The zero-based iteration count, which is incremented after each call to the `callbackFn`\r\n * and any `isDone` function (if provided), the `iter` property is accessible withing the callback\r\n * function and may be overwritten within the callback function.\r\n * - `res` - The last resolved result value returned by the `callbackFn` function.\r\n * - `isDone` - A boolean value or a callback function that will be called to check if the while loop\r\n * should stop, the `isDone` property is accessible withing the callback function and may be\r\n * overwritten within the callback function.\r\n * - The callback function may return either a value or a promise, if a promise is returned the while\r\n * loop will wait until the promise is resolved before calling the callback function again.\r\n * - If the callback function throws an error when executing `synchronously` the exception will\r\n * also be thrown `synchronously` otherwise the returned promise will be rejected with the error.\r\n * @example\r\n * ```ts\r\n * // Synchronous example\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     return \"Hello\";\r\n *  }\r\n * });\r\n *\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Synchronous example with isDoneFn\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     return \"Hello\";\r\n *  }\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Asynchronous examples\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   state.isDone = true;\r\n *   return createResolvedPromise(\"Darkness\");\r\n * });\r\n * console.log(result); // Darkness\r\n *\r\n * // Asynchronous example with isDoneFn\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   return createResolvedPromise(\"Darkness\");\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Darkness after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Combination Synchronous and Asynchronous example\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await\r\n * const result = await doWhileAsync(async (state) => {\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await and dynamically setting the isDone function\r\n * const result = await doWhileAsync(async (state) => {\r\n *   // dynamically set the isDone function\r\n *   if (state.idx < 10) {\r\n *     state.isDone = () => return false;\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = () => return true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n * ```\r\n */\r\nexport function doWhileAsync<T>(callbackFn: (state: IWhileState<T>) => T | IPromise<T>, isDoneFn?: (state: IWhileState<T>) => boolean | void | IPromise<boolean | void>, thisArg?: any): T | IPromise<T> {\r\n    let promise: T | IPromise<T>;\r\n    let resolve: ResolvePromiseHandler<T>;\r\n    let reject: RejectPromiseHandler | never = (reason: any) => {\r\n        isDone = true;\r\n        throw reason;\r\n    };\r\n    let isDone = false;\r\n    let state: IWhileState<T> = {\r\n        st: utcNow(),\r\n        iter: 0,\r\n        isDone: isDoneFn || false\r\n    };\r\n\r\n    if (callbackFn) {\r\n        const _createPromise = (): IPromise<T> => {\r\n            return createPromise<T>((res, rej) => {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n        };\r\n\r\n        const _handleAsyncDone = (done: boolean) => {\r\n            isDone = !!done;\r\n            if (!isDone) {\r\n                _processNext();\r\n            } else {\r\n                resolve(state.res);\r\n            }\r\n        };\r\n\r\n        const _processNext = (): T | IPromise<T> => {\r\n            // Attempt to process the next item synchronously if possible (for performance -- to reduce the number of promises created)\r\n            while (!isDone) {\r\n                try {\r\n                    let cbResult = callbackFn.call(thisArg, state);\r\n                    if (isPromiseLike(cbResult)) {\r\n                        promise = promise || _createPromise();\r\n                        doAwait(cbResult, (res) => {\r\n                            try {\r\n                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone, reject);\r\n                            } catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        }, reject);\r\n\r\n                        // Break out of synchronous loop and wait for promise to resolve\r\n                        return promise;\r\n                    } else {\r\n                        let dnRes = _doneChk(isDone, state, cbResult, thisArg);\r\n                        if (isPromiseLike(dnRes)) {\r\n                            promise = promise || _createPromise();\r\n                            doAwait(dnRes, _handleAsyncDone, reject);\r\n\r\n                            // Break out of synchronous loop and wait for promise to resolve\r\n                            return promise;\r\n                        } else {\r\n                            isDone = !!dnRes;\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                    return promise;\r\n                }\r\n            }\r\n            \r\n            if (isDone && resolve) {\r\n                resolve(state.res);\r\n            }\r\n\r\n            return promise || state.res;\r\n        };\r\n    \r\n        return _processNext();\r\n    }\r\n}"]}