{"version":3,"file":"arrForEachAsync.js","sourceRoot":"","sources":["../../../../src/helpers/arrForEachAsync.ts"],"names":[],"mappings":"AAQA,OAAO,EAAE,SAAS,EAAE,MAAM,qBAAqB,CAAC;AAEhD,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAgE9C,MAAM,UAAU,eAAe,CAAU,QAAsB,EAAE,UAA4F,EAAE,OAAa;IACxK,IAAI,QAAQ,EAAE;QACV,MAAM,GAAG,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC;QAChC,IAAI,GAAG,EAAE;YACL,MAAM,MAAM,GAAG,CAAC,KAAiC,EAAE,EAAE;gBACjD,IAAI,KAAK,CAAC,IAAI,IAAI,GAAG,IAAI,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE;oBACvC,OAAO,IAAI,CAAC;iBACf;YACL,CAAC,CAAC;YAEF,OAAO,YAAY,CAAC,CAAC,KAAK,EAAE,EAAE;gBAC1B,MAAM,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC;gBACvB,IAAI,GAAG,IAAI,QAAQ,EAAE;oBACjB,OAAO,UAAU,CAAC,IAAI,CAAC,OAAO,IAAI,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;iBAC7E;YACL,CAAC,EAAE,MAAM,CAAC,CAAC;SACd;KACJ;AACL,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getLength } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in an array (or ArratLike) instance in ascending index order. It is not invoked\r\n * for index properties that have been deleted or are uninitialized. And unlike the ES6 forEach() this supports async functions and you CAN stop\r\n * or break the iteration  by returning -1 from the `callbackFn` function.\r\n *\r\n * The range (number of elements) processed by arrForEach() is set before the first call to the `callbackFn`. Any elements added beyond the range\r\n * or elements which as assigned to indexes already processed will not be visited by the `callbackFn`.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise` then the next iteration will not be\r\n * called until the promise is resolved. If the `callbackFn` returns a `Promise` that is rejected then the iteration will stop and the promise\r\n * returned by arrForEachAsync will be rejected with the same error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the element type of the array\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A `asynchronous` or `synchronous` function that accepts up to three arguments. arrForEach calls the callbackfn function one\r\n * time for each element in the array.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the array will be used as the this value.\r\n * @remarks\r\n * arrForEachAsync supports either a `synchronous` or `asynchronous` (returns a `Promise`) callback function. If the callback function returns\r\n * a `Promise` then the next iteration will not be called until the promise is resolved. If the callback function returns a `Promise` that is\r\n * rejected then the iteration will stop and the promise returned by arrForEachAsync will be rejected with the same error.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * arrForEachASync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * // Also supports input as an array like object\r\n * const items = { length: 3, 0: 'item1', 1: 'item2', 2: 'item3' };\r\n *\r\n * // Asynchronous examples using await\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * await arrForEachASync(items, (value, index) => { // Note: DO NOT use async here unless you use await within the function\r\n *   if (index < 5) {\r\n *     // Logs each iteration index\r\n *     // Logs each value\r\n *     console.log(value);\r\n *     // Returning a promise will cause `arrForEachAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true);\r\n *   }\r\n *\r\n *   return -1; // Stop the iteration\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * ```\r\n */\r\nexport function arrForEachAsync<T = any>(theArray: ArrayLike<T>, callbackFn: (value: T, index: number, array: T[]) => void | number | IPromise<void | number>, thisArg?: any): void | number | IPromise<void | number> {\r\n    if (theArray) {\r\n        const len = getLength(theArray);\r\n        if (len) {\r\n            const isDone = (state: IWhileState<void | number>) => {\r\n                if (state.iter >= len || state.res === -1) {\r\n                    return true;\r\n                }\r\n            };\r\n\r\n            return doWhileAsync((state) => {\r\n                const idx = state.iter;\r\n                if (idx in theArray) {\r\n                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);\r\n                }\r\n            }, isDone);\r\n        }\r\n    }\r\n}"]}