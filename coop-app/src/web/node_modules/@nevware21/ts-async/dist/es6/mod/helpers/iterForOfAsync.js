import { createCachedValue, fnCall, getKnownSymbol, isIterator, isPromiseLike } from "@nevware21/ts-utils";
import { doWhileAsync } from "./doWhileAsync";
import { DONE, RETURN, VALUE } from "../internal/constants";
import { doAwait, doFinally } from "../promise/await";
let _iterSymbol;
let _iterAsyncSymbol;
export function iterForOfAsync(iter, callbackFn, thisArg) {
    let err;
    let iterResult;
    let theIter = iter;
    function onFailed(failed) {
        err = { e: failed };
        if (theIter.throw) {
            iterResult = null;
            theIter.throw(err);
        }
        throw failed;
    }
    function onFinally() {
        try {
            if (iterResult && !iterResult[DONE]) {
                theIter[RETURN] && theIter[RETURN](iterResult);
            }
        }
        finally {
            if (err) {
                throw err.e;
            }
        }
    }
    if (iter) {
        if (!isIterator(iter)) {
            !_iterAsyncSymbol && (_iterAsyncSymbol = createCachedValue(getKnownSymbol(0)));
            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;
            if (!theIter) {
                !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(3)));
                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;
            }
        }
        if (theIter && isIterator(theIter)) {
            let result;
            try {
                result = doWhileAsync((state) => {
                    return doAwait(theIter.next(), (res) => {
                        iterResult = res;
                        if (!res[DONE]) {
                            return fnCall(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);
                        }
                    }, (reason) => {
                        state.isDone = true;
                        onFailed(reason);
                    });
                }, (state) => {
                    if (!iterResult || iterResult[DONE] || state.res === -1) {
                        onFinally();
                        return true;
                    }
                }, thisArg || theIter);
                if (isPromiseLike(result)) {
                    result = doFinally(result.catch(onFailed), onFinally);
                }
                return result;
            }
            catch (failed) {
                onFailed(failed);
            }
            finally {
                if (result && !isPromiseLike(result)) {
                    onFinally();
                }
            }
        }
    }
}
//# sourceMappingURL=iterForOfAsync.js.map