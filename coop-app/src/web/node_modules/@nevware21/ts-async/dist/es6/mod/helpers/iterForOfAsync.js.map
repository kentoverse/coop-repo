{"version":3,"file":"iterForOfAsync.js","sourceRoot":"","sources":["../../../../src/helpers/iterForOfAsync.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ICachedValue, WellKnownSymbols, createCachedValue, fnCall, getKnownSymbol, isIterator, isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\nimport { DONE, RETURN, VALUE } from \"../internal/constants\";\r\nimport { doAwait, doFinally } from \"../promise/await\";\r\n\r\nlet _iterSymbol: ICachedValue<symbol>;\r\nlet _iterAsyncSymbol: ICachedValue<symbol>;\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in the iterator or iterator returned by\r\n * the iterable and processed in the same order as returned by the iterator. As with the {@link arrForEachAsync}\r\n * you CAN stop or break the iteration by returning -1 from the `callbackFn` function.\r\n *\r\n * The order of processing is not reset if you add or remove elemenets to the iterator, the actual behavior will\r\n * depend on the iterator implementation.\r\n *\r\n * if the passed `iter` is both an Iterable<T> and Iterator<T> the Iterator<T> interface takes precedence. And if\r\n * an iterable and does not have a `Symbol.iterator` property then the `iter` will be used as the iterator.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise`\r\n * then the next iteration will not be called until the promise is resolved. If the `callbackFn` returns a `Promise`\r\n * that is rejected then the iteration will stop and the promise returned by iterForEachAsync will be rejected with\r\n * the same error.\r\n * @remarks\r\n * If Symbols are NOT supported then the iterable MUST be using the same polyFill for the well know symbols, as used\r\n * by the library. If the iterable is using a different polyFill then the `iter` MUST be an Iterator<T> and not an\r\n * Iterable<T>.\r\n * If you are targetting a mixed environment you SHOULD either\r\n * - only use the polyfill Symbol's provided by this library\r\n * - ensure that you add any symbol polyfills BEFORE these utilities\r\n * iterForOfAsync\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the iterator\r\n * @param iter - The iterator or iterable of elements to be searched.\r\n * @param callbackFn - A `asynchronous` or `synchronous` function that accepts up to three arguments. iterForEach\r\n * calls the callbackfn function one time for each element in the iterator.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted,\r\n * null or undefined the iterator will be used as the this value.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * // using async / await\r\n * let result = await iterForOfAsync(items, async (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   await createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  })\r\n *\r\n * console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *\r\n * // using doAwait\r\n * doAwait(iterForOfAsync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   return createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  }), (result) => {\r\n *    console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *  });\r\n */\r\nexport function iterForOfAsync<T = any>(iter: Iterator<T> | Iterable<T> | AsyncIterator<T> | AsyncIterable<T>, callbackFn: (value: T, count: number, iter?: Iterator<T> | AsyncIterator<T>) => void | number | IPromise<void | number>, thisArg?: any): void | number | IPromise<void | number> {\r\n    let err: { e: any };\r\n    let iterResult: IteratorResult<T>;\r\n    let theIter: AsyncIterator<T> | Iterator<T> = iter as AsyncIterator<T> | Iterator<T>;\r\n\r\n    function onFailed(failed: any): never  {\r\n        err = { e: failed };\r\n        if (theIter.throw) {\r\n            iterResult = null;\r\n            theIter.throw(err);\r\n        }\r\n\r\n        throw failed;\r\n    }\r\n\r\n    function onFinally() {\r\n        try {\r\n            if (iterResult && !iterResult[DONE]) {\r\n                theIter[RETURN] && theIter[RETURN](iterResult);\r\n            }\r\n        } finally {\r\n            if (err) {\r\n                // eslint-disable-next-line no-unsafe-finally\r\n                throw err.e;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (iter) {\r\n        if (!isIterator(iter)) {\r\n            // Get the asyncIterator from the iterable\r\n            !_iterAsyncSymbol && (_iterAsyncSymbol = createCachedValue(getKnownSymbol(WellKnownSymbols.asyncIterator)));\r\n            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;\r\n            if (!theIter) {\r\n                // Get the iterator from the iterable\r\n                !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(WellKnownSymbols.iterator)));\r\n                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\r\n            }\r\n        }\r\n        \r\n        if (theIter && isIterator(theIter)) {\r\n\r\n            let result: void | number | IPromise<void | number>;\r\n            try {\r\n                result = doWhileAsync((state) => {\r\n                    return doAwait(theIter.next(), (res) => {\r\n                        iterResult = res;\r\n                        if (!res[DONE]) {\r\n                            return fnCall(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);\r\n                        }\r\n                    }, (reason) => {\r\n                        state.isDone = true;\r\n                        onFailed(reason);\r\n                    });\r\n                }, (state: IWhileState<void | number>) => {\r\n                    if (!iterResult || iterResult[DONE] || state.res === -1) {\r\n                        onFinally();\r\n                        return true;\r\n                    }\r\n                }, thisArg || theIter);\r\n\r\n                if (isPromiseLike(result)) {\r\n                    result = doFinally(result.catch(onFailed), onFinally);\r\n                }\r\n\r\n                return result;\r\n            } catch (failed) {\r\n                onFailed(failed);\r\n            } finally {\r\n                if (result && !isPromiseLike(result)) {\r\n                    onFinally();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"]}