import { arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined, throwTypeError, objToString, scheduleTimeout, getWindow, isNode, getGlobal, objDefine, objDefineProp, lazySafeGetInst, iterForOf, isIterable, isArray, arrForEach, createCachedValue, safe, getInst, createCustomError } from "@nevware21/ts-utils";
import { doAwait, doAwaitResponse } from "./await";
import { _addDebugState, _promiseDebugEnabled } from "./debug";
import { STRING_STATES } from "../internal/state";
import { emitEvent } from "./event";
import { REJECTED, STR_PROMISE } from "../internal/constants";
const NODE_UNHANDLED_REJECTION = "unhandledRejection";
const UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
let _currentPromiseId = [];
let _uniquePromiseId = 0;
let _unhandledRejectionTimeout = 10;
let _aggregationError;
let _hasPromiseRejectionEvent;
function dumpFnObj(value) {
    if (isFunction(value)) {
        return value.toString();
    }
    return dumpObj(value);
}
function _createAggregationError(values) {
    !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, ["AggregationError"]).v || createCustomError("AggregationError", (self, args) => {
        self.errors = args[0];
    })));
    return new _aggregationError.v(values);
}
export function _createPromise(newPromise, processor, executor) {
    let additionalArgs = arrSlice(arguments, 3);
    let _state = 0;
    let _hasResolved = false;
    let _settledValue;
    let _queue = [];
    let _id = _uniquePromiseId++;
    let _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;
    let _handled = false;
    let _unHandledRejectionHandler = null;
    let _thePromise;
    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + "RejectionEvent"));
    function _then(onResolved, onRejected) {
        try {
            _currentPromiseId.push(_id);
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            let thenPromise = newPromise(function (resolve, reject) {
                _queue.push(function () {
                    try {
                        let handler = _state === 2 ? onResolved : onRejected;
                        let value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                        if (isPromiseLike(value)) {
                            value.then(resolve, reject);
                        }
                        else if (handler) {
                            resolve(value);
                        }
                        else if (_state === 3) {
                            reject(value);
                        }
                        else {
                            resolve(value);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
                if (_hasResolved) {
                    _processQueue();
                }
            }, additionalArgs);
            return thenPromise;
        }
        finally {
            _currentPromiseId.pop();
        }
    }
    function _catch(onRejected) {
        return _then(undefined, onRejected);
    }
    function _finally(onFinally) {
        let thenFinally = onFinally;
        let catchFinally = onFinally;
        if (isFunction(onFinally)) {
            thenFinally = function (value) {
                onFinally && onFinally();
                return value;
            };
            catchFinally = function (reason) {
                onFinally && onFinally();
                throw reason;
            };
        }
        return _then(thenFinally, catchFinally);
    }
    function _strState() {
        return STRING_STATES[_state];
    }
    function _processQueue() {
        if (_queue.length > 0) {
            let pending = _queue.slice();
            _queue = [];
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            processor(pending);
        }
        else {
        }
    }
    function _createSettleIfFn(newState, allowState) {
        return (theValue) => {
            if (_state === allowState) {
                if (newState === 2 && isPromiseLike(theValue)) {
                    _state = 1;
                    theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
                    return;
                }
                _state = newState;
                _hasResolved = true;
                _settledValue = theValue;
                _processQueue();
                if (!_handled && newState === 3 && !_unHandledRejectionHandler) {
                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                }
            }
            else {
            }
        };
    }
    function _notifyUnhandledRejection() {
        if (!_handled) {
            _handled = true;
            if (isNode()) {
                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            }
            else {
                let gbl = getWindow() || getGlobal();
                emitEvent(gbl, UNHANDLED_REJECTION, (theEvt) => {
                    objDefine(theEvt, "promise", { g: () => _thePromise });
                    theEvt.reason = _settledValue;
                    return theEvt;
                }, !!_hasPromiseRejectionEvent.v);
            }
        }
    }
    _thePromise = {
        then: _then,
        "catch": _catch,
        finally: _finally
    };
    objDefineProp(_thePromise, "state", {
        get: _strState
    });
    if (_promiseDebugEnabled) {
        _addDebugState(_thePromise, _strState, () => { return objToString(_settledValue); }, () => _handled);
    }
    if (hasSymbol()) {
        _thePromise[getKnownSymbol(11)] = "IPromise";
    }
    let createStack;
    function _toString() {
        return "IPromise" + (_promiseDebugEnabled ? "[" + _id + (!isUndefined(_parentId) ? (":" + _parentId) : "") + "]" : "") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "") + (createStack ? " @ " + createStack : "");
    }
    _thePromise.toString = _toString;
    (function _initialize() {
        if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
        }
        const _rejectFn = _createSettleIfFn(3, 0);
        try {
            executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
        }
        catch (e) {
            _rejectFn(e);
        }
    })();
    return _thePromise;
}
export function _createAllPromise(newPromise) {
    return function (input) {
        let additionalArgs = arrSlice(arguments, 1);
        return newPromise((resolve, reject) => {
            try {
                let values = [];
                let pending = 1;
                iterForOf(input, (item, idx) => {
                    if (item) {
                        pending++;
                        doAwait(item, (value) => {
                            values[idx] = value;
                            if (--pending === 0) {
                                resolve(values);
                            }
                        }, reject);
                    }
                });
                pending--;
                if (pending === 0) {
                    resolve(values);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    };
}
export function _createResolvedPromise(newPromise) {
    return function (value) {
        let additionalArgs = arrSlice(arguments, 1);
        if (isPromiseLike(value)) {
            return value;
        }
        return newPromise((resolve) => {
            resolve(value);
        }, additionalArgs);
    };
}
export function _createRejectedPromise(newPromise) {
    return function (reason) {
        let additionalArgs = arrSlice(arguments, 1);
        return newPromise((_resolve, reject) => {
            reject(reason);
        }, additionalArgs);
    };
}
export function _createAllSettledPromise(newPromise, ..._args) {
    return createCachedValue(function (input, ..._args) {
        let additionalArgs = arrSlice(arguments, 1);
        return newPromise((resolve, reject) => {
            let values = [];
            let pending = 1;
            function processItem(item, idx) {
                pending++;
                doAwaitResponse(item, (value) => {
                    if (value.rejected) {
                        values[idx] = {
                            status: REJECTED,
                            reason: value.reason
                        };
                    }
                    else {
                        values[idx] = {
                            status: "fulfilled",
                            value: value.value
                        };
                    }
                    if (--pending === 0) {
                        resolve(values);
                    }
                });
            }
            try {
                if (isArray(input)) {
                    arrForEach(input, processItem);
                }
                else if (isIterable(input)) {
                    iterForOf(input, processItem);
                }
                else {
                    throwTypeError("Input is not an iterable");
                }
                pending--;
                if (pending === 0) {
                    resolve(values);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}
export function _createRacePromise(newPromise, ..._args) {
    return createCachedValue(function (input, ..._args) {
        let additionalArgs = arrSlice(arguments, 1);
        return newPromise((resolve, reject) => {
            let isDone = false;
            function processItem(item) {
                doAwaitResponse(item, (value) => {
                    if (!isDone) {
                        isDone = true;
                        if (value.rejected) {
                            reject(value.reason);
                        }
                        else {
                            resolve(value.value);
                        }
                    }
                });
            }
            try {
                if (isArray(input)) {
                    arrForEach(input, processItem);
                }
                else if (isIterable(input)) {
                    iterForOf(input, processItem);
                }
                else {
                    throwTypeError("Input is not an iterable");
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}
export function _createAnyPromise(newPromise, ..._args) {
    return createCachedValue(function (input, ..._args) {
        let additionalArgs = arrSlice(arguments, 1);
        return newPromise((resolve, reject) => {
            let theErros = [];
            let pending = 1;
            let isDone = false;
            function processItem(item, idx) {
                pending++;
                doAwaitResponse(item, (value) => {
                    if (!value.rejected) {
                        isDone = true;
                        resolve(value.value);
                        return;
                    }
                    else {
                        theErros[idx] = value.reason;
                    }
                    if (--pending === 0 && !isDone) {
                        reject(_createAggregationError(theErros));
                    }
                });
            }
            try {
                if (isArray(input)) {
                    arrForEach(input, processItem);
                }
                else if (isIterable(input)) {
                    iterForOf(input, processItem);
                }
                else {
                    throwTypeError("Input is not an iterable");
                }
                pending--;
                if (pending === 0 && !isDone) {
                    reject(_createAggregationError(theErros));
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}
//# sourceMappingURL=base.js.map